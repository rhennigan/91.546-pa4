// Generated by CoffeeScript 1.9.1
(function() {
  var Color, FFAIL, FINIT, FREDY, FSTRT, MAT_F32, MAT_UI16, Mat, Mat4, Object3D, TestClass, VEC_F32, VEC_UI16, VFAIL, VINIT, VREDY, VSTRT, Vec, Vec2, Vec3, Vec4, WebGLScene, normals, object, triangles, vertices,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  MAT_F32 = VEC_F32 = typeof Float32Array !== "undefined" && Float32Array !== null ? Float32Array : Array;

  MAT_UI16 = VEC_UI16 = typeof Uint16Array !== "undefined" && Uint16Array !== null ? Uint16Array : Array;

  Vec = (function() {
    function Vec() {}

    Vec.add = function(v1, v2) {
      var i, j, ref, v3;
      if (v1.length === v2.length) {
        v3 = new VEC_F32(v1.length);
        for (i = j = 0, ref = v1.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
          v3[i] = v1[i] + v2[i];
        }
        return v3;
      }
    };

    Vec.sub = function(v1, v2) {
      var i, j, ref, v3;
      if (v1.length === v2.length) {
        v3 = new VEC_F32(v1.length);
        for (i = j = 0, ref = v1.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
          v3[i] = v1[i] - v2[i];
        }
        return v3;
      } else {
        return alert("vector dimensions must agree");
      }
    };

    Vec.norm = function(v) {
      var i, j, ref, s;
      s = 0;
      for (i = j = 0, ref = v.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
        s += v[i] * v[i];
      }
      return Math.sqrt(s);
    };

    Vec.dist = function(v1, v2) {
      var d, i, j, ref, s;
      if (v1.length === v2.length) {
        s = 0;
        for (i = j = 0, ref = v1.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
          d = v1[i] - v2[i];
          s += d * d;
        }
        return Math.sqrt(s);
      } else {
        return alert("vector dimensions must agree");
      }
    };

    Vec.neg = function(v) {
      var i, j, ref, u;
      u = new VEC_F32(v.length);
      for (i = j = 0, ref = v.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
        u[i] = -v[i];
      }
      return u;
    };

    return Vec;

  })();

  Vec2 = (function(superClass) {
    extend(Vec2, superClass);

    function Vec2() {
      return Vec2.__super__.constructor.apply(this, arguments);
    }

    Vec2.create = function(x, y) {
      if (x == null) {
        x = 0;
      }
      if (y == null) {
        y = 0;
      }
      return new VEC_F32([x, y]);
    };

    return Vec2;

  })(Vec);

  Vec3 = (function(superClass) {
    extend(Vec3, superClass);

    function Vec3() {
      return Vec3.__super__.constructor.apply(this, arguments);
    }

    Vec3.create = function(x, y, z) {
      if (x == null) {
        x = 0;
      }
      if (y == null) {
        y = 0;
      }
      if (z == null) {
        z = 0;
      }
      return new VEC_F32([x, y, z]);
    };

    return Vec3;

  })(Vec);

  Vec4 = (function(superClass) {
    extend(Vec4, superClass);

    function Vec4() {
      return Vec4.__super__.constructor.apply(this, arguments);
    }

    Vec4.create = function(x, y, z, w) {
      if (x == null) {
        x = 0;
      }
      if (y == null) {
        y = 0;
      }
      if (z == null) {
        z = 0;
      }
      if (w == null) {
        w = 0;
      }
      return new VEC_F32([x, y, z, w]);
    };

    return Vec4;

  })(Vec);

  Mat = (function() {
    function Mat() {}

    return Mat;

  })();

  Mat4 = (function(superClass) {
    extend(Mat4, superClass);

    function Mat4() {
      return Mat4.__super__.constructor.apply(this, arguments);
    }

    return Mat4;

  })(Mat);

  Color = (function() {
    function Color(r, g, b, a) {
      this.r = r != null ? r : 0.0;
      this.g = g != null ? g : 0.0;
      this.b = b != null ? b : 0.0;
      this.a = a != null ? a : 1.0;
    }

    return Color;

  })();

  Object3D = (function() {
    Object3D.prototype.arrays = {
      vertices: void 0,
      triangles: void 0,
      normals: void 0
    };

    Object3D.prototype.buffers = {
      vertexBuffer: void 0,
      triangleBuffer: void 0,
      normalBuffer: void 0
    };

    function Object3D(GL, vertices, triangles, normals) {
      this.arrays.vertices = new MAT_F32(vertices);
      this.arrays.triangles = new MAT_UI16(triangles);
      this.arrays.normals = new MAT_F32(normals);
      this.buffers.vertexBuffer = GL.createBuffer();
      this.buffers.triangleBuffer = GL.createBuffer();
      this.buffers.normalBuffer = GL.createBuffer();
    }

    Object3D.prototype.draw = function(GL) {
      GL.bindBuffer(GL.ARRAY_BUFFER, this.buffers.vertexBuffer);
      GL.bufferData(GL.ARRAY_BUFFER, this.arrays.vertices, GL.STATIC_DRAW);
      GL.bindBuffer(GL.ARRAY_BUFFER, this.buffers.normalBuffer);
      GL.bufferData(GL.ARRAY_BUFFER, this.arrays.normals, GL.STATIC_DRAW);
      GL.bindBuffer(GL.ELEMENT_ARRAY_BUFFER, this.buffers.triangleBuffer);
      return GL.bufferData(GL.ELEMENT_ARRAY_BUFFER, this.arrays.triangles, gl.STATIC_DRAW);
    };

    return Object3D;

  })();

  FINIT = 1;

  VINIT = 2;

  FSTRT = 4;

  VSTRT = 8;

  FREDY = 16;

  VREDY = 32;

  FFAIL = 64;

  VFAIL = 128;

  WebGLScene = (function() {
    WebGLScene.prototype.canvas = void 0;

    WebGLScene.prototype.GL = void 0;

    WebGLScene.prototype.options = {
      clearColor: new Color(),
      clearDepth: 1.0,
      depthTest: true
    };

    WebGLScene.prototype.shaderSource = {
      status: FINIT | VINIT,
      1: void 0,
      2: void 0
    };

    WebGLScene.prototype.objects = [];

    WebGLScene.prototype.shaders = void 0;

    function WebGLScene(canvasID, fragShaderPath, vertShaderPath, options) {
      this._getShaderScript = bind(this._getShaderScript, this);
      this.canvas = document.getElementById(canvasID);
      this.GL = this._getWebGLContext(this.canvas);
      this.options = this._setGLOptions(options != null ? options : this.options);
      this._initGLShaders(fragShaderPath, vertShaderPath);
      this.objects = [];
    }

    WebGLScene.prototype.drawScene = function() {
      return this.GL.clear(this.GL.COLOR_BUFFER_BIT | this.GL.DEPTH_BUFFER_BIT);
    };

    WebGLScene.prototype._getWebGLContext = function(canvas) {
      var e;
      try {
        return canvas.getContext("experimental-webgl");
      } catch (_error) {
        e = _error;
        return alert(e);
      }
    };

    WebGLScene.prototype._setGLOptions = function(options) {
      var c;
      c = options.clearColor;
      this.GL.clearColor(c.r, c.g, c.b, c.a);
      this.GL.clearDepth(options.clearDepth);
      if (options.depthTest) {
        this.GL.enable(this.GL.DEPTH_TEST);
        this.GL.depthFunc(this.GL.LEQUAL);
      } else {
        this.GL.disable(this.GL.DEPTH_TEST);
      }
      return options;
    };

    WebGLScene.prototype._getShaderScript = function(path, type) {
      var request;
      this.shaderSource.status |= type << 2;
      request = new XMLHttpRequest();
      request.open('GET', path, true);
      request.onreadystatechange = (function(_this) {
        return function() {
          if (request.readyState === 4 && request.status === 200) {
            _this.shaderSource[type] = request.responseText;
            return _this.shaderSource.status |= type << 4;
          } else {

          }
        };
      })(this);
      return request.send();
    };

    WebGLScene.prototype._initGLShaders = function(fragPath, vertPath) {
      var RETRY_TIME, msg, ready, starting, waiting;
      RETRY_TIME = 50;
      starting = FINIT | VINIT;
      waiting = starting | FSTRT | VSTRT;
      ready = waiting | FREDY | VREDY;
      switch (this.shaderSource.status) {
        case starting:
          this._getShaderScript(fragPath, 1);
          this._getShaderScript(vertPath, 2);
          return setTimeout(((function(_this) {
            return function() {
              return _this._initGLShaders(fragPath, vertPath);
            };
          })(this)), RETRY_TIME);
        case FSTRT | starting:
          this._getShaderScript(vertPath, 2);
          return setTimeout(((function(_this) {
            return function() {
              return _this._initGLShaders(fragPath, vertPath);
            };
          })(this)), RETRY_TIME);
        case VSTRT | starting:
          this._getShaderScript(fragPath, 1);
          return setTimeout(((function(_this) {
            return function() {
              return _this._initGLShaders(fragPath, vertPath);
            };
          })(this)), RETRY_TIME);
        case waiting:
        case waiting | FREDY:
        case waiting | VREDY:
          return setTimeout(((function(_this) {
            return function() {
              return _this._initGLShaders(fragPath, vertPath);
            };
          })(this)), RETRY_TIME);
        default:
          if (this.shaderSource.status !== ready) {
            alert("failed: " + this.shaderSource.status);
          }
          this.shaders = {
            frag: this.GL.createShader(this.GL.FRAGMENT_SHADER),
            vert: this.GL.createShader(this.GL.VERTEX_SHADER)
          };
          this.GL.shaderSource(this.shaders.frag, this.shaderSource[1]);
          this.GL.shaderSource(this.shaders.vert, this.shaderSource[2]);
          this.GL.compileShader(this.shaders.frag);
          this.GL.compileShader(this.shaders.vert);
          if (!this.GL.getShaderParameter(this.shaders.frag, this.GL.COMPILE_STATUS)) {
            msg = this.GL.getShaderInfoLog(this.shaders.frag);
            alert("An error occurred compiling the shaders: " + msg);
            this.shaderSource.status |= FFAIL;
          }
          if (!this.GL.getShaderParameter(this.shaders.vert, this.GL.COMPILE_STATUS)) {
            msg = this.GL.getShaderInfoLog(this.shaders.vert);
            alert("An error occurred compiling the shaders: " + msg);
            this.shaderSource.status |= VFAIL;
          }
          return this.shaderSource.status;
      }
    };

    return WebGLScene;

  })();

  TestClass = (function() {
    function TestClass() {
      this.fun2();
    }

    TestClass.prototype.fun1 = function() {
      return console.log("fun1 called");
    };

    TestClass.prototype.fun2 = function() {
      return this.fun1();
    };

    return TestClass;

  })();

  window.scene = new WebGLScene('canvas', 'shaders/simple_frag.glsl', 'shaders/3d_vert.glsl');

  vertices = [-1.0, -1.0, 1.0, 1.0, -1.0, 1.0, 1.0, 1.0, 1.0, -1.0, 1.0, 1.0, -1.0, -1.0, -1.0, -1.0, 1.0, -1.0, 1.0, 1.0, -1.0, 1.0, -1.0, -1.0, -1.0, 1.0, -1.0, -1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, -1.0, -1.0, -1.0, -1.0, 1.0, -1.0, -1.0, 1.0, -1.0, 1.0, -1.0, -1.0, 1.0, 1.0, -1.0, -1.0, 1.0, 1.0, -1.0, 1.0, 1.0, 1.0, 1.0, -1.0, 1.0, -1.0, -1.0, -1.0, -1.0, -1.0, 1.0, -1.0, 1.0, 1.0, -1.0, 1.0, -1.0];

  triangles = [0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7, 8, 9, 10, 8, 10, 11, 12, 13, 14, 12, 14, 15, 16, 17, 18, 16, 18, 19, 20, 21, 22, 20, 22, 23];

  normals = [0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0];

  object = new Object3D(scene.GL, vertices, triangles, normals);

  scene.objects.push(object);

  console.log(scene);

}).call(this);

//# sourceMappingURL=main.js.map
